import { createHydratableSignal } from '@solid-primitives/utils';
import { createSignal, onMount, onCleanup, createEffect, createUniqueId, untrack } from 'solid-js';
import { isServer } from 'solid-js/web';
import { reconcile } from 'solid-js/store';

var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
function createStorage(props) {
  const [error, setError] = createSignal();
  const handleError = props?.throw ? (err, fallback) => {
    setError(err instanceof Error ? err : new Error(fallback));
    throw err;
  } : (err, fallback) => {
    setError(err instanceof Error ? err : new Error(fallback));
  };
  const apis = props?.api ? Array.isArray(props.api) ? props.api : [props.api] : [globalThis.localStorage].filter(Boolean);
  const prefix = props?.prefix ? `${props.prefix}.` : "";
  const signals = /* @__PURE__ */ new Map();
  const store = new Proxy(
    {},
    {
      get(_, key) {
        let node = signals.get(key);
        if (!node) {
          node = createSignal(void 0, { equals: false });
          signals.set(key, node);
        }
        node[0]();
        const value = apis.reduce(
          (result, api) => {
            if (result !== null || !api) {
              return result;
            }
            try {
              return api.getItem(`${prefix}${key}`);
            } catch (err) {
              handleError(err, `Error reading ${prefix}${key} from ${api["name"]}`);
              return null;
            }
          },
          null
        );
        if (value !== null && props?.deserializer) {
          return props.deserializer(value, key, props.options);
        }
        return value;
      }
    }
  );
  const setter = (key, value, options) => {
    const filteredValue = props?.serializer ? props.serializer(value, key, options ?? props.options) : value;
    const apiKey = `${prefix}${key}`;
    apis.forEach((api) => {
      try {
        api.getItem(apiKey) !== filteredValue && api.setItem(apiKey, filteredValue);
      } catch (err) {
        handleError(err, `Error setting ${prefix}${key} to ${filteredValue} in ${api.name}`);
      }
    });
    const node = signals.get(key);
    node && node[1]();
  };
  const remove = (key) => apis.forEach((api) => {
    try {
      api.removeItem(`${prefix}${key}`);
    } catch (err) {
      handleError(err, `Error removing ${prefix}${key} from ${api.name}`);
    }
  });
  const clear = () => apis.forEach((api) => {
    try {
      api.clear();
    } catch (err) {
      handleError(err, `Error clearing ${api.name}`);
    }
  });
  const toJSON = () => {
    const result = {};
    const addValue = (key, value) => {
      if (!result.hasOwnProperty(key)) {
        const filteredValue = value && props?.deserializer ? props.deserializer(value, key, props.options) : value;
        if (filteredValue) {
          result[key] = filteredValue;
        }
      }
    };
    apis.forEach((api) => {
      if (typeof api.getAll === "function") {
        let values;
        try {
          values = api.getAll();
        } catch (err) {
          handleError(err, `Error getting all values from in ${api.name}`);
        }
        for (const key of values) {
          addValue(key, values[key]);
        }
      } else {
        let index = 0, key;
        try {
          while (key = api.key(index++)) {
            if (!result.hasOwnProperty(key)) {
              addValue(key, api.getItem(key));
            }
          }
        } catch (err) {
          handleError(err, `Error getting all values from ${api.name}`);
        }
      }
    });
    return result;
  };
  props?.sync !== false && onMount(() => {
    const listener = (ev) => {
      let changed = false;
      apis.forEach((api) => {
        try {
          if (api !== ev.storageArea && ev.key && ev.newValue !== api.getItem(ev.key)) {
            ev.newValue ? api.setItem(ev.key, ev.newValue) : api.removeItem(ev.key);
            changed = true;
          }
        } catch (err) {
          handleError(
            err,
            `Error synching api ${api.name} from storage event (${ev.key}=${ev.newValue})`
          );
        }
      });
      changed && ev.key && signals.get(ev.key)?.[1]();
    };
    if ("addEventListener" in globalThis) {
      globalThis.addEventListener("storage", listener);
      onCleanup(() => globalThis.removeEventListener("storage", listener));
    } else {
      apis.forEach((api) => api.addEventListener?.("storage", listener));
      onCleanup(() => apis.forEach((api) => api.removeEventListener?.("storage", listener)));
    }
  });
  return [
    store,
    setter,
    {
      clear,
      error,
      remove,
      toJSON
    }
  ];
}
function createAsyncStorage(props) {
  const [error, setError] = createSignal();
  const handleError = props?.throw ? (err, fallback) => {
    setError(err instanceof Error ? err : new Error(fallback));
    throw err;
  } : (err, fallback) => {
    setError(err instanceof Error ? err : new Error(fallback));
  };
  const apis = props?.api ? Array.isArray(props.api) ? props.api : [props.api] : [];
  const prefix = props?.prefix ? `${props.prefix}.` : "";
  const signals = /* @__PURE__ */ new Map();
  const store = new Proxy({}, {
    get(_, key) {
      let node = signals.get(key);
      if (!node) {
        node = createSignal(void 0, { equals: false });
        signals.set(key, node);
      }
      node[0]();
      return apis.reduce((result, api) => {
        if (result !== null || !api) {
          return result;
        }
        let value;
        try {
          value = api.getItem(`${prefix}${key}`);
        } catch (err) {
          handleError(err, `Error getting ${prefix}${key} from ${api.name}`);
        }
        if (value instanceof Promise) {
          return value.then(
            (newValue) => newValue && props?.deserializer ? props.deserializer(newValue, key, props.options) : newValue
          );
        }
        return value !== null && props?.deserializer ? Promise.resolve(props.deserializer(value, key, props.options)) : Promise.resolve(value);
      }, null);
    }
  });
  const setter = (key, value, options) => {
    const filteredValue = props?.serializer ? props.serializer(value, key, options ?? props.options) : value;
    return Promise.all(
      apis.map((api) => {
        try {
          api.setItem(`${prefix}${key}`, filteredValue, options ?? props?.options);
        } catch (err) {
          handleError(err, `Error setting ${prefix}${key} to ${filteredValue} in ${api.name}`);
        }
      })
    ).then(() => {
      const node = signals.get(key);
      node && node[1]();
    });
  };
  const remove = (key) => {
    Promise.all(
      apis.map((api) => {
        try {
          api.removeItem(`${prefix}${key}`);
        } catch (err) {
          handleError(err, `Error removing ${prefix}${key} from ${api.name}`);
        }
      })
    ).then(() => {
      const node = signals.get(key);
      node && node[1]();
    });
  };
  const clear = () => Promise.all(
    apis.map(async (api) => {
      let index = 0, key;
      while (key = await api.key(index++)) {
        try {
          await api.removeItem(key);
        } catch (err) {
          handleError(err, `Error removing ${key} from ${api.name} during clear()`);
        }
      }
    })
  ).then(() => {
    return;
  });
  const toJSON = async () => {
    const result = {};
    const addValue = (key, value) => {
      if (!result.hasOwnProperty(key)) {
        const filteredValue = value && props?.deserializer ? props.deserializer(value, key, props.options) : value;
        if (filteredValue) {
          result[key] = filteredValue;
        }
      }
    };
    await Promise.all(
      apis.map(async (api) => {
        if (typeof api.getAll === "function") {
          try {
            const values = await api.getAll();
            for (const key of values) {
              addValue(key, values[key]);
            }
          } catch (err) {
            handleError(err, `Error attempting to get all keys from ${api.name}`);
          }
        } else {
          let index = 0, key;
          try {
            while (key = await api.key(index++)) {
              addValue(key, await api.getItem(key));
            }
          } catch (err) {
            handleError(err, `Error attempting to get all keys from ${api.name}`);
          }
        }
      })
    );
    return result;
  };
  props?.sync !== false && onMount(() => {
    const listener = (ev) => {
      let changed = false;
      apis.forEach(async (api) => {
        try {
          if (api !== ev.storageArea && ev.key && ev.newValue !== await api.getItem(ev.key)) {
            ev.newValue ? api.setItem(ev.key, ev.newValue) : api.removeItem(ev.key);
            changed = true;
          }
        } catch (err) {
          handleError(err, "Error attempting to sync on event");
        }
      });
      changed && ev.key && signals.get(ev.key)?.[1]();
    };
    if ("addEventListener" in globalThis) {
      globalThis.addEventListener("storage", listener);
      onCleanup(() => globalThis.removeEventListener("storage", listener));
    } else {
      apis.forEach((api) => api.addEventListener?.("storage", listener));
      onCleanup(() => apis.forEach((api) => api.removeEventListener?.("storage", listener)));
    }
  });
  return [
    store,
    setter,
    {
      remove,
      clear,
      error,
      toJSON
    }
  ];
}
function createStorageSignal(key, initialValue, props) {
  const [error, setError] = createSignal();
  const apis = props?.api ? Array.isArray(props.api) ? props.api : [props.api] : [globalThis.localStorage].filter(Boolean);
  const prefix = props?.prefix ? `${props.prefix}.` : "";
  const read = () => apis.reduce((result, api) => {
    if (result !== null || !api) {
      return result;
    }
    let value = null;
    try {
      value = api.getItem(`${prefix}${key}`);
    } catch (err) {
      setError(
        err instanceof Error ? err : new Error(`Error reading ${prefix}${key} from ${api.name}`)
      );
      if (props?.throw) {
        throw err;
      }
    }
    if (value !== null && props?.deserializer) {
      return props.deserializer(value + "", key, props.options);
    }
    return value;
  }, null);
  const [accessor, setter] = createHydratableSignal(
    initialValue,
    () => read() ?? initialValue,
    props
  );
  createEffect(() => {
    const value = accessor();
    const filteredValue = props?.serializer ? props.serializer(value, key, props.options) : value + "";
    const apiKey = `${prefix}${key}`;
    try {
      if (value === null) {
        apis.forEach((api) => api.getItem(apiKey) !== null && api.removeItem(apiKey));
      } else {
        apis.forEach(
          (api) => api.getItem(apiKey) !== filteredValue && api.setItem(apiKey, filteredValue, props?.options)
        );
      }
    } catch (err) {
      setError(
        err instanceof Error ? err : new Error(`Error ${value === null ? "removing" : "writing"} value`)
      );
      if (props?.throw) {
        throw err;
      }
    }
  });
  const refetch = () => {
    const value = read();
    setter(value);
  };
  props?.sync !== false && onMount(() => {
    const listener = (ev) => {
      let changed = false;
      try {
        apis.forEach((api) => {
          if (api !== ev.storageArea && ev.key && ev.newValue !== api.getItem(ev.key)) {
            ev.newValue ? api.setItem(ev.key, ev.newValue) : api.removeItem(ev.key);
            changed = true;
          }
        });
      } catch (err) {
        setError(err instanceof Error ? err : new Error("Error synching api after event"));
        if (props?.throw) {
          throw err;
        }
      }
      changed && refetch();
    };
    if ("addEventListener" in globalThis) {
      globalThis.addEventListener("storage", listener);
      onCleanup(() => globalThis.removeEventListener("storage", listener));
    } else {
      apis.forEach((api) => api.addEventListener?.("storage", listener));
      onCleanup(() => apis.forEach((api) => api.removeEventListener?.("storage", listener)));
    }
  });
  return [Object.assign(accessor, { error }), setter, refetch];
}
var createLocalStorage = createStorage;
var createSessionStorage = (props) => createStorage({ ...props, api: globalThis.sessionStorage });

// src/tools.ts
var addClearMethod = (storage) => {
  if (typeof storage.clear === "function") {
    return storage;
  }
  storage.clear = () => {
    let key;
    while (key = storage.key(0)) {
      storage.removeItem(key);
    }
  };
  return storage;
};

// src/cookies.ts
var serializeCookieOptions = (options) => {
  if (!options) {
    return "";
  }
  let memo = "";
  for (const key in options) {
    if (!options.hasOwnProperty(key)) {
      continue;
    }
    const value = options[key];
    memo += value instanceof Date ? `; ${key}=${value.toUTCString()}` : typeof value === "boolean" ? `; ${key}` : `; ${key}=${value}`;
  }
  return memo;
};
var useRequest;
try {
  useRequest = __require("solid-start/server").useRequest;
} catch (e) {
  useRequest = () => {
    console.warn(
      "It seems you attempt to use cookieStorage on the server without having solid-start installed"
    );
    return {
      request: { headers: { get: () => "" } }
    };
  };
}
var cookieStorage = addClearMethod({
  _read: isServer ? (options) => {
    const eventOrRequest = options?.getRequest?.() || useRequest();
    const request = eventOrRequest && ("request" in eventOrRequest ? eventOrRequest.request : eventOrRequest);
    return request?.headers.get("Cookie") || "";
  } : () => document.cookie,
  _write: isServer ? (key, value, options) => options?.setCookie?.(key, value, options) : (key, value, options) => {
    document.cookie = `${key}=${value}${serializeCookieOptions(options)}`;
  },
  getItem: (key, options) => cookieStorage._read(options).match("(^|;)\\s*" + key + "\\s*=\\s*([^;]+)")?.pop() ?? null,
  setItem: (key, value, options) => {
    const oldValue = cookieStorage.getItem(key);
    cookieStorage._write(key, value, options);
    const storageEvent = Object.assign(new Event("storage"), {
      key,
      oldValue,
      newValue: value,
      url: globalThis.document.URL,
      storageArea: cookieStorage
    });
    window.dispatchEvent(storageEvent);
  },
  removeItem: (key) => {
    cookieStorage._write(key, "deleted", { expires: /* @__PURE__ */ new Date(0) });
  },
  key: (index) => {
    let key = null;
    let count = 0;
    cookieStorage._read().replace(/(?:^|;)\s*(.+?)\s*=\s*[^;]+/g, (_, found) => {
      if (!key && found && count++ === index) {
        key = found;
      }
      return "";
    });
    return key;
  },
  get length() {
    let length = 0;
    cookieStorage._read().replace(/(?:^|;)\s*.+?\s*=\s*[^;]+/g, (found) => {
      length += found ? 1 : 0;
      return "";
    });
    return length;
  }
});
var createCookieStorage = (props) => createStorage({ ...props, api: cookieStorage });
function makePersisted(signal, options = {}) {
  const storage = options.storage || globalThis.localStorage;
  if (!storage) {
    return signal;
  }
  const name = options.name || `storage-${createUniqueId()}`;
  const serialize = options.serialize || JSON.stringify.bind(JSON);
  const deserialize = options.deserialize || JSON.parse.bind(JSON);
  const init = storage.getItem(name, options.storageOptions);
  const set = typeof signal[0] === "function" ? (data) => signal[1](() => deserialize(data)) : (data) => signal[1](reconcile(deserialize(data)));
  let unchanged = true;
  if (init instanceof Promise) {
    init.then((data) => unchanged && data && set(data));
  } else if (init) {
    set(init);
  }
  return [
    signal[0],
    typeof signal[0] === "function" ? (value) => {
      const output = signal[1](value);
      value != null ? (
        // @ts-ignore
        storage.setItem(name, serialize(output), options.storageOptions)
      ) : storage.removeItem(name);
      unchanged = false;
      return output;
    } : (...args) => {
      signal[1](...args);
      storage.setItem(
        name,
        serialize(untrack(() => signal[0])),
        // @ts-ignore
        options.storageOptions
      );
      unchanged = false;
    }
  ];
}

export { addClearMethod, cookieStorage, createAsyncStorage, createCookieStorage, createLocalStorage, createSessionStorage, createStorage, createStorageSignal, makePersisted };
