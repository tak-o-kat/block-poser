declare function info<T>(data: T): T;
declare function log(...args: any[]): undefined;
declare function warn(...args: any[]): undefined;
declare function error(...args: any[]): undefined;
declare function formatTime(d?: Date): string;
declare function interceptPropertySet<TObject extends object, TKey extends keyof TObject>(obj: TObject, key: TKey, cb: (value: TObject[TKey]) => void): void;
declare const asArray: <T>(value: T) => (T extends any[] ? T[number] : T)[];
declare function callArrayProp<K extends PropertyKey, T extends (...args: Args) => void, Args extends unknown[]>(object: {
    [_ in K]?: T[];
}, key: K, ...args: Args): void;
declare function pushToArrayProp<K extends PropertyKey, T>(object: {
    [_ in K]?: T[];
}, key: K, value: T): T[];
declare function mutateFilter<T, S extends T>(array: T[], predicate: (value: T, index: number, array: T[]) => value is S): void;
declare function mutateFilter<T>(array: T[], predicate: (value: T, index: number, array: T[]) => unknown): void;
declare function mutateRemove<T>(array: T[], item: T): void;
declare const dedupeArray: <T>(array: readonly T[]) => T[];
/** Checks if both arrays contain the same values. Order doesn't matter. */
declare const arrayRefEquals: <T>(a: readonly T[], b: readonly T[]) => boolean;
/** function that trims too long string */
declare function trimString(str: string, maxLength: number): string;
declare function findIndexById<T extends {
    id: string;
}>(array: T[], id: string): number;
declare function findItemById<T extends {
    id: string;
}>(array: T[], id: string): T | undefined;
declare const splitOnColon: <T extends string>(str: T) => T extends `${infer L}:${infer R}` ? [L, R] : [T, null];
declare function whileArray<T, U>(toCheck: T[], callback: (item: T, toCheck: T[]) => U | undefined): U | undefined;
declare const isRecord: (value: unknown) => value is Record<string, unknown>;
declare const XOR: (a: unknown, b: unknown) => unknown;
type ToDyscriminatedUnion<T extends {}, TK extends PropertyKey = 'type', DK extends void | PropertyKey = void> = {
    [K in keyof T]: {
        [k in TK]: K;
    } & (DK extends PropertyKey ? {
        [k in DK]: T[K];
    } : T[K]);
}[keyof T];
declare function dedupeArrayById<T extends {
    id: unknown;
}>(input: T[]): T[];

export { ToDyscriminatedUnion, XOR, arrayRefEquals, asArray, callArrayProp, dedupeArray, dedupeArrayById, error, findIndexById, findItemById, formatTime, info, interceptPropertySet, isRecord, log, mutateFilter, mutateRemove, pushToArrayProp, splitOnColon, trimString, warn, whileArray };
