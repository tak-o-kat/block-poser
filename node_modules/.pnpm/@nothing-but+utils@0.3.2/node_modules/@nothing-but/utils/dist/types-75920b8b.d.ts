/**
 * Can be single or in an array
 */
type Many<T> = T | T[];
type AnyObject = Record<PropertyKey, any>;
type EmptyObject = Record<PropertyKey, never>;
type AnyFunction = (...args: any[]) => any;
type Noop = (...a: any[]) => void;
type AnyClass = abstract new (...args: any) => any;
type Primitive = PropertyKey | boolean | bigint | null | undefined;
type FalsyValue = false | null | undefined;
type Truthy<T> = Exclude<T, FalsyValue>;
type Falsy<T> = Extract<T, FalsyValue>;
/**
 * Represents a point in 2D space with x and y coordinates.
 */
type Position = {
    x: number;
    y: number;
};
type Size = {
    width: number;
    height: number;
};
/**
 * Infers the type of the array elements
 */
type ItemsOf<T> = T extends any[] ? T[number] : T;
/** Allows to make shallow overwrites to an interface */
type Modify<T, R> = Omit<T, keyof R> & R;
/** Allows to make nested overwrites to an interface */
type ModifyDeep<A extends AnyObject, B extends DeepPartialAny<A>> = {
    [K in keyof A]: B[K] extends never ? A[K] : B[K] extends AnyObject ? ModifyDeep<A[K], B[K]> : B[K];
} & (A extends AnyObject ? Omit<B, keyof A> : A);
/** Makes each property optional and turns each leaf property into any, allowing for type overrides by narrowing any. */
type DeepPartialAny<T> = {
    [P in keyof T]?: T[P] extends AnyObject ? DeepPartialAny<T[P]> : any;
};
/** Removes the `[...list]` functionality */
type NonIterable<T> = T & {
    [Symbol.iterator]: never;
};
/** Get the required keys of an object */
type RequiredKeys<T> = keyof {
    [K in keyof T as T extends {
        [_ in K]: unknown;
    } ? K : never]: 0;
};
/** Remove the first item of a tuple [1, 2, 3, 4] => [2, 3, 4] */
type Tail<T extends any[]> = ((...t: T) => void) extends (x: any, ...u: infer U) => void ? U : never;
/** `A | B => A & B` */
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
type ExtractIfPossible<T, U> = Extract<T, U> extends never ? U : Extract<T, U>;
/** Unwraps the type definition of an object, making it more readable */
type Simplify<T> = T extends object ? {
    [K in keyof T]: T[K];
} : T;
/** Unboxes type definition, making it more readable */
type UnboxLazy<T> = T extends () => infer U ? U : T;
type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
type RawNarrow<T> = (T extends [] ? [] : never) | (T extends string | number | bigint | boolean ? T : never) | {
    [K in keyof T]: T[K] extends Function ? T[K] : RawNarrow<T[K]>;
};
type Narrow<T extends any> = T extends [] ? T : RawNarrow<T>;
type NoInfer<T> = [T][T extends any ? 0 : never];
/**
 * Enumerate<N> creates a union of numbers from 0 to N-1
 *
 * @example
 * Enumerate<3> // 0 | 1 | 2
 */
type Enumerate<N extends number, Acc extends number[] = []> = Acc['length'] extends N ? Acc[number] : Enumerate<N, [...Acc, Acc['length']]>;

type types_AnyClass = AnyClass;
type types_AnyFunction = AnyFunction;
type types_AnyObject = AnyObject;
type types_DeepPartialAny<T> = DeepPartialAny<T>;
type types_EmptyObject = EmptyObject;
type types_Enumerate<N extends number, Acc extends number[] = []> = Enumerate<N, Acc>;
type types_ExtractIfPossible<T, U> = ExtractIfPossible<T, U>;
type types_Falsy<T> = Falsy<T>;
type types_FalsyValue = FalsyValue;
type types_ItemsOf<T> = ItemsOf<T>;
type types_Many<T> = Many<T>;
type types_Modify<T, R> = Modify<T, R>;
type types_ModifyDeep<A extends AnyObject, B extends DeepPartialAny<A>> = ModifyDeep<A, B>;
type types_Narrow<T extends any> = Narrow<T>;
type types_NoInfer<T> = NoInfer<T>;
type types_NonIterable<T> = NonIterable<T>;
type types_Noop = Noop;
type types_Position = Position;
type types_Prettify<T> = Prettify<T>;
type types_Primitive = Primitive;
type types_RequiredKeys<T> = RequiredKeys<T>;
type types_Simplify<T> = Simplify<T>;
type types_Size = Size;
type types_Tail<T extends any[]> = Tail<T>;
type types_Truthy<T> = Truthy<T>;
type types_UnboxLazy<T> = UnboxLazy<T>;
type types_UnionToIntersection<U> = UnionToIntersection<U>;
declare namespace types {
  export {
    types_AnyClass as AnyClass,
    types_AnyFunction as AnyFunction,
    types_AnyObject as AnyObject,
    types_DeepPartialAny as DeepPartialAny,
    types_EmptyObject as EmptyObject,
    types_Enumerate as Enumerate,
    types_ExtractIfPossible as ExtractIfPossible,
    types_Falsy as Falsy,
    types_FalsyValue as FalsyValue,
    types_ItemsOf as ItemsOf,
    types_Many as Many,
    types_Modify as Modify,
    types_ModifyDeep as ModifyDeep,
    types_Narrow as Narrow,
    types_NoInfer as NoInfer,
    types_NonIterable as NonIterable,
    types_Noop as Noop,
    types_Position as Position,
    types_Prettify as Prettify,
    types_Primitive as Primitive,
    types_RequiredKeys as RequiredKeys,
    types_Simplify as Simplify,
    types_Size as Size,
    types_Tail as Tail,
    types_Truthy as Truthy,
    types_UnboxLazy as UnboxLazy,
    types_UnionToIntersection as UnionToIntersection,
  };
}

export { AnyClass as A, DeepPartialAny as D, EmptyObject as E, FalsyValue as F, ItemsOf as I, Many as M, Noop as N, Position as P, RequiredKeys as R, Size as S, Truthy as T, UnionToIntersection as U, AnyObject as a, AnyFunction as b, Primitive as c, Falsy as d, Modify as e, ModifyDeep as f, NonIterable as g, Tail as h, ExtractIfPossible as i, Simplify as j, UnboxLazy as k, Prettify as l, Narrow as m, NoInfer as n, Enumerate as o, types as t };
