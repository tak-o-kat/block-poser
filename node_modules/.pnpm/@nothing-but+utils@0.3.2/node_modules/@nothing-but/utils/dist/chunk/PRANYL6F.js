import { math_exports } from './77EWK6YV.js';
import { __export } from './5ZKAE4VZ.js';

// src/array.ts
var array_exports = {};
__export(array_exports, {
  binaryInsert: () => binaryInsert,
  binaryInsertUnique: () => binaryInsertUnique,
  binaryInsertWith: () => binaryInsertWith,
  binarySearch: () => binarySearch,
  binarySearchWith: () => binarySearchWith,
  deduped: () => deduped,
  equals: () => equals,
  includesSameMembers: () => includesSameMembers,
  mutateFilter: () => mutateFilter,
  pickRandom: () => pickRandom,
  pickRandomExclidingOne: () => pickRandomExclidingOne,
  randomIterate: () => randomIterate,
  remove: () => remove,
  wrap: () => wrap
});
function equals(a, b) {
  return a === b || a.length === b.length && a.every((e, i) => e === b[i]);
}
function wrap(arr, index) {
  return arr[math_exports.remainder(index, arr.length)];
}
function includesSameMembers(a, b) {
  if (a === b)
    return true;
  if (a.length !== b.length)
    return false;
  const copy = b.slice();
  let found = 0;
  a_loop:
    for (let i = 0; i < a.length; i++) {
      const a_item = a[i];
      for (let j = found; j < b.length; j++) {
        const b_item = copy[j];
        if (a_item === b_item) {
          [copy[j], copy[found]] = [copy[found], copy[j]];
          found = j + 1;
          continue a_loop;
        }
      }
      return false;
    }
  return true;
}
function deduped(array) {
  return Array.from(new Set(array));
}
function mutateFilter(array, predicate) {
  const temp = array.filter(predicate);
  array.length = 0;
  array.push.apply(array, temp);
}
function remove(array, item) {
  array.splice(array.indexOf(item), 1);
}
var pickRandom = (arr) => arr[math_exports.randomInt(arr.length)];
function pickRandomExclidingOne(arr, excluding) {
  let pick_index = math_exports.randomInt(arr.length), pick = arr[pick_index];
  if (pick === excluding) {
    pick_index = (pick_index + 1) % arr.length;
    pick = arr[pick_index];
  }
  return pick;
}
function* randomIterate(arr) {
  const copy = arr.slice();
  while (copy.length) {
    const index = math_exports.randomInt(copy.length);
    yield copy.splice(index, 1)[0];
  }
}
function binarySearch(arr, item) {
  let low = 0, high = arr.length - 1, mid, guess;
  while (low <= high) {
    mid = Math.floor((low + high) / 2);
    guess = arr[mid];
    if (guess === item) {
      return mid;
    } else if (guess > item) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return;
}
function binarySearchWith(arr, item, getComparable) {
  const search_for = getComparable(item);
  let low = 0, high = arr.length - 1, mid, guess_item, guess_for;
  while (low <= high) {
    mid = low + high >> 1;
    guess_item = arr[mid];
    guess_for = getComparable(guess_item);
    if (guess_item === item) {
      return mid;
    } else if (guess_for === search_for) {
      let i = mid - 1;
      for (; i >= 0 && getComparable(arr[i]) === guess_for; i--) {
        if (arr[i] === item)
          return i;
      }
      i = mid + 1;
      for (; i < arr.length && getComparable(arr[i]) === guess_for; i++) {
        if (arr[i] === item)
          return i;
      }
    } else if (guess_for > search_for) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return;
}
function binaryInsertUnique(arr, item) {
  let low = 0, high = arr.length - 1, mid, guess;
  while (low <= high) {
    mid = Math.floor((low + high) / 2);
    guess = arr[mid];
    if (guess === item) {
      return;
    } else if (guess > item) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  arr.splice(low, 0, item);
}
function binaryInsert(arr, item) {
  let low = 0, high = arr.length - 1, mid, guess;
  while (low <= high) {
    mid = Math.floor((low + high) / 2);
    guess = arr[mid];
    if (guess === item) {
      arr.splice(mid, 0, item);
      return;
    } else if (guess > item) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  arr.splice(low, 0, item);
}
function binaryInsertWith(arr, item, getComparable) {
  const search_for = getComparable(item);
  let low = 0, high = arr.length - 1, mid, guess_item, guess_for;
  while (low <= high) {
    mid = Math.floor((low + high) / 2);
    guess_item = arr[mid];
    guess_for = getComparable(guess_item);
    if (guess_for === search_for) {
      arr.splice(mid, 0, item);
      return;
    } else if (guess_for > search_for) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  arr.splice(low, 0, item);
}

export { array_exports, binaryInsert, binaryInsertUnique, binaryInsertWith, binarySearch, binarySearchWith, deduped, equals, includesSameMembers, mutateFilter, pickRandom, pickRandomExclidingOne, randomIterate, remove, wrap };
