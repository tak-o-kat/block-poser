import { __export } from './5ZKAE4VZ.js';

// src/color.ts
var color_exports = {};
__export(color_exports, {
  RGB: () => RGB,
  RGBA: () => RGBA,
  hex_to_rgb: () => hex_to_rgb,
  hex_to_rgba: () => hex_to_rgba,
  rgb_int: () => rgb_int,
  rgb_int_to_rgb: () => rgb_int_to_rgb,
  rgb_to_hex: () => rgb_to_hex,
  rgb_to_rgba: () => rgb_to_rgba,
  rgb_to_rgba_int: () => rgb_to_rgba_int,
  rgb_to_string: () => rgb_to_string,
  rgb_value: () => rgb_value,
  rgba_int: () => rgba_int,
  rgba_int_to_rgba: () => rgba_int_to_rgba,
  rgba_to_hex: () => rgba_to_hex,
  rgba_to_string: () => rgba_to_string
});
var RGB = class {
  /**
   * Creates an instance of the RGB class.
   * @param r - The red component of the RGB color.
   * @param g - The green component of the RGB color.
   * @param b - The blue component of the RGB color.
   */
  constructor(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
  }
  /**
   * Returns a string representation of the RGB color in the format "rgb(r g b)".
   */
  toString = rgb_to_string.bind(null, this);
};
var RGBA = class extends RGB {
  /**
   * Creates an instance of the RGBA class.
   * @param r - The red component of the RGBA color.
   * @param g - The green component of the RGBA color.
   * @param b - The blue component of the RGBA color.
   * @param a - The alpha component (opacity) of the RGBA color.
   */
  constructor(r, g, b, a) {
    super(r, g, b);
    this.a = a;
  }
  /**
   * Returns a string representation of the RGBA color in the format "rgb(r g b / a)".
   */
  toString = rgba_to_string.bind(null, this);
};
function rgb_to_string(rgb) {
  return `rgb(${rgb.r} ${rgb.g} ${rgb.b})`;
}
function rgba_to_string(rgba) {
  return `rgb(${rgba.r} ${rgba.g} ${rgba.b} / ${rgba.a})`;
}
function rgb_to_rgba(rgb, a) {
  return new RGBA(rgb.r, rgb.g, rgb.b, a);
}
function rgb_int(rgb) {
  return rgb.r << 16 | rgb.g << 8 | rgb.b;
}
function rgb_int_to_rgb(value) {
  return new RGB(value >> 16 & 255, value >> 8 & 255, value & 255);
}
function rgba_int(rgba) {
  return rgba.r << 24 | rgba.g << 16 | rgba.b << 8 | rgba.a;
}
function rgba_int_to_rgba(value) {
  return new RGBA(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
}
function rgb_to_rgba_int(rgb, a) {
  return rgb_int(rgb) << 8 | a;
}
function rgb_value(rgb) {
  return `${rgb.r} ${rgb.g} ${rgb.b}`;
}
function rgb_to_hex(rgb) {
  return "#" + rgb.r.toString(16) + rgb.g.toString(16) + rgb.b.toString(16);
}
function rgba_to_hex(rgba) {
  return "#" + rgba.r.toString(16) + rgba.g.toString(16) + rgba.b.toString(16) + rgba.a.toString(16);
}
function hex_to_rgb(hex) {
  if (hex[0] === "#")
    hex = hex.slice(1);
  if (hex.length < 6) {
    const r2 = parseInt(hex[0], 16);
    const g2 = parseInt(hex[1], 16);
    const b2 = parseInt(hex[2], 16);
    return new RGB(r2, g2, b2);
  }
  const r = parseInt(hex.slice(0, 2), 16);
  const g = parseInt(hex.slice(2, 4), 16);
  const b = parseInt(hex.slice(4, 6), 16);
  return new RGB(r, g, b);
}
function hex_to_rgba(hex) {
  if (hex[0] === "#")
    hex = hex.slice(1);
  if (hex.length < 6) {
    const r2 = parseInt(hex[0], 16);
    const g2 = parseInt(hex[1], 16);
    const b2 = parseInt(hex[2], 16);
    const a2 = hex[3] ? parseInt(hex[3], 16) / 255 : 1;
    return new RGBA(r2, g2, b2, a2);
  }
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  const a = hex.length > 7 ? parseInt(hex.slice(7, 9), 16) / 255 : 1;
  return new RGBA(r, g, b, a);
}

export { RGB, RGBA, color_exports, hex_to_rgb, hex_to_rgba, rgb_int, rgb_int_to_rgb, rgb_to_hex, rgb_to_rgba, rgb_to_rgba_int, rgb_to_string, rgb_value, rgba_int, rgba_int_to_rgba, rgba_to_hex, rgba_to_string };
